thing: vec3 {
    x: num,
    y: num,
    z: num
}

$vec3 { my = vec3(0, 0, 0); }
$vec3 (x: num, y: num, z: num) {
    my.x = x;
    my.y = y;
    my.z = z;
}

@x: num -> vec3 { ret my.x; }
@y: num -> vec3 { ret my.y; }
@z: num -> vec3 { ret my.z; }

@(-): vec3 -> vec3 { ret vec3(-my.x, -my.y, -my.z); }
@e: num (i: num) -> vec3 {
    switch (i) {
        case 0: ret my.x;
        case 1: ret my.y;
        case 2: ret my.z;
        default: ret 0;
    }
}

@(+): vec3 (v: vec3) -> vec3 {
    my.x += v.x;
    my.y += v.y;
    my.z += v.z;
    ret my;
}

@(*): vec3 (t: num) -> vec3 {
    my.x *= t;
    my.y *= t;
    my.z *= t;
    ret my;
}

@(/): vec3 (t: num) -> vec3 {
    ret my.mul(1 / t);
}

@length: num -> vec3 {
    ret sqrt(my.length_squared());
}

@length_squared: num -> vec3 {
    ret (my.x * my.x) + (my.y * my.y) + (my.z * my.z);
}

alias point3 : vec3; ## point3 is just an alias for vec3, but useful for geometric clarity in the code.
$point3 { my = vec3(); }
$point3 (x: num, y: num, z: num) { my = vec3(x, y, z); }

## Vector Utility Functions

@out (v: vec3) {
    out("[ %f %f %f ]", v.x, v.y, v.z);
}

@(+): vec3 (u: vec3, v: vec3) {
    ret vec3(u.x + v.x, u.y + v.y, u.z + v.z);
}

@(-): vec3 (u: vec3, v: vec3) {
    ret vec3(u.x - v.x, u.y - v.y, u.z - v.z);
}

@(*): vec3 (u: vec3, v: vec3) {
    ret vec3(u.x * v.x, u.y * v.y, u.z * v.z);
}

@(*): vec3 (t: num, v: vec3) {
    ret vec3(t * v.x, t * v.y, t * v.z);
}

@(*): vec3 (v: vec3, t: num) {
    ret t * v;
}

@(/): vec3 (v: vec3, t: num) {
    ret (1 / t) * v;
}

@dot: num (u: vec3, v: vec3) {
    ret (u.x * v.x) + (u.y * v.y) + (u.z * v.z);
}

@cross: vec3 (u: vec3, v: vec3) {
    ret vec3(
        (u.y * v.z) - (u.z * v.y),
        (u.z * v.x) - (u.x * v.z),
        (u.x * v.y) - (u.y * v.x)
    );
}

@unit_vector: vec3 (v: vec3) {
    ret v / v.length();
}
